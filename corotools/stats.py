from .objects import dataset
import numpy as np
import pandas as pd
from tabulate import tabulate

def get_country_weekly_stat(list_of_time_series_dictionaries, populations_dict, countrykey, timeoffset=0):
    """
    create a dictionary with weekly stats on numbers, changes, relative numbers and changes,
    changes of rate

    Parameters
    ----------
    list_of_time_series_dictionaries : list containing dictionaries with country, e.g. generated by
                                       get_jhu_data()
    populations_dict : dict containing populations of all countries,
                       e.g. generate by get_populations()
    countrykey : string for the country to make the stats for
    timeoffset : time offset in days (optional)

    returns : dictionary containing several stat values
    """
    def subfill(M, subs, countrykey, rd, timeoffset):
        adata = dataset(M[countrykey], countrykey)
        rd[subs] = adata.y[-1-timeoffset] 
        rd['%s_perpop'%subs] = rd[subs] / rd['population']
        y_lastweek = adata.y[-8-timeoffset]
        y_twoweeksago = adata.y[-15-timeoffset]
        rd['%s_delta'%subs] = rd[subs] - y_lastweek
        rd['%s_delta_perpop'%subs] = rd['%s_delta'%subs] / rd['population']
        rd['%s_delta_relative'%subs] = rd['%s_delta'%subs] / y_lastweek
        rd['%s_ratechange'%subs] = (rd[subs] - y_lastweek) / (y_lastweek-y_twoweeksago)-1
        return rd
    rd = {}    
    Md = list_of_time_series_dictionaries[0].copy()
    Mdea = list_of_time_series_dictionaries[1].copy()
    Mdact = list_of_time_series_dictionaries[2].copy()
    Mdrec = list_of_time_series_dictionaries[3].copy()
    rd['key'] = countrykey
    rd['population'] = populations_dict[countrykey]
    rd = subfill(Md, 'cases', countrykey, rd,timeoffset)
    rd = subfill(Mdea, 'dead', countrykey, rd,timeoffset)
    rd = subfill(Mdact, 'active', countrykey, rd,timeoffset)
    rd = subfill(Mdrec, 'recovered', countrykey, rd,timeoffset)
    return rd

def get_country_weekly_stat_table(list_of_time_series_dictionaries, populations_dict, countrykey, timeoffset=0,
                                  tableformat = 'simple'):
    """
        create a printable table (using tabulate module) of weekly stats for one country

        Parameters
        ----------
        list_of_time_series_dictionaries : list containing dictionaries with country, e.g. generated by
                                           get_jhu_data()
        populations_dict : dict containing populations of all countries,
                           e.g. generate by get_populations()
        countrykey : string for the country to make the stats for
        timeoffset : time offset in days (optional)
        tableformat : formatting used by 'tabulate' (optional)

        Returns
        -------
        printable table (as string)

        """
    rd = get_country_weekly_stat(list_of_time_series_dictionaries, populations_dict, countrykey, timeoffset=timeoffset)
    L = [["cases",
          "%.0f k"%(rd['cases']/1e3),
          "%.1f k"%(rd['cases_delta']/1e3),
          "%.0f%%"%(rd['cases_delta_relative']*100),
          "%.0f%%"%(rd['cases_ratechange']*100)],
        ["",
         "%.1f /k"%(rd['cases_perpop']*1e3),
         "%.0f /m"%(rd['cases_delta_perpop']*1e6)],
        ["dead",
         "%.1f k"%(rd['dead']/1e3),
          "%.2f k"%(rd['dead_delta']/1e3),
          "%.0f%%"%(rd['dead_delta_relative']*100),
          "%.0f%%"%(rd['dead_ratechange']*100)],
        ["",
         "%.0f /m"%(rd['dead_perpop']*1e6),
         "%.0f /m"%(rd['dead_delta_perpop']*1e6)],]
    
    return(tabulate(L,
                   headers=["weekly","num","diff","diff %","acc %"],
                   tablefmt=tableformat,
                   colalign=("right","right","right","right"),
                   ))
    
def get_metatable(list_of_time_series_dictionaries, populations_dict, countrykey_list, ignore_list=[], timeoffset=0):
    """create pandas dataframe with get_country_stat values for key in countrykey_list

    Parameters
    ----------
    list_of_time_series_dictionaries : list containing dictionaries with country, e.g. generated by
                                           get_jhu_data()
    populations_dict : dict containing populations of all countries,
                       e.g. generate by get_populations()
    countrykey_list : list of country keys
    ingnore_list : list with country keys to exclude (optional)
    timeoffset : time offset in days (optional)

    returns
    -------
    pandas dataframe
    """
    newDF = pd.DataFrame() 
    for k in countrykey_list:
        if k not in ignore_list:
            s = get_country_weekly_stat( list_of_time_series_dictionaries, populations_dict, k, timeoffset=timeoffset)
            if len(k)>10: # make abbreviation of long names
                s['key10'] = k[0:10]
            else:
                s['key10'] = k
            tmpdf = pd.DataFrame([[s[x] for x in s.keys()]],
                                columns=[x for x in s.keys()])
            newDF=newDF.append(tmpdf,ignore_index=True)
    return newDF

def get_metatable124(list_of_time_series_dictionaries, populations_dict, countrykey_list, ignore_list=[], timeoffset=0):
    """create pandas dataframes with get_country_stat values for key in countrykey_list for last, -2 and -4 weeks

    Parameters
    ----------
    list_of_time_series_dictionaries : list containing dictionaries with country, e.g. generated by
                                           get_jhu_data()
    populations_dict : dict containing populations of all countries,
                       e.g. generate by get_populations()
    countrykey_list : list of country keys
    ignore_list : list with country keys to exclude (optional)
    timeoffset : time offset in days (optional)

    Returns
    -------
    mt, mt2, mt4 : pandas dataframes
    """
    mt = get_metatable(list_of_time_series_dictionaries, populations_dict, countrykey_list, ignore_list=ignore_list,  timeoffset = timeoffset )
    mt2 = get_metatable(list_of_time_series_dictionaries, populations_dict, countrykey_list, ignore_list=ignore_list,  timeoffset = timeoffset + 15)
    mt4 = get_metatable(list_of_time_series_dictionaries, populations_dict, countrykey_list, ignore_list=ignore_list,  timeoffset = timeoffset + 29)
    return mt, mt2, mt4

def sort_df_and_get_keys(dF, sortkey, num=10, ascending=False):
    """ sort dataframe by sortkey, return num keys in ascending(descending) order

    Parameters
    ----------
    dF : pandas dataframe
    sortkey : key for which the data will be sorted
    num : number of entries in result (optional)
    ascending : boolean whether to sort ascending or not (optional

    Returns
    -------
    pandas dataframe with sorted data"""
    newDF = dF.sort_values(by=sortkey, ascending=ascending)
    return [x for x in newDF['key'][0:num] ]

def get_rank_table_from_df2(metatable, metatable2, metatable4, sortkey,
                           columns, factors,
                           columnalias = None,
                           num=10, ascending=False,
                           mininf=2000,
                           tableformat = 'github',
                           floatfmt='.1f'):
    """
    create a metatable comparing different countries

    metatable : metatable for actual week (created by get_metatable124)
    metatable2 : metatable for two weeks ago (created by get_metatable124)
    metatable4 : metatable for four weeks ago created by get_metatable124)
    sortkey : key to sort the metable (e.g. 'cases')
    columns : list of columns to be printed
    factors : list or array of numerical scaling factors (e.g. [1., 1/100, 100])
    columnalias : list of column aliases (printed to the table head), optional
    num: number of entries (column rows), optional, default = 10
    ascending: boolean, optional, default = false
    mininf : number of minimum infections to consider, entries with smaller values will
            be disregarded, optional, default = 2000
    tableformat : format for tabulate, optional, default = github
    floatfmt : float format for tabulate, optional, default = '%.1f'

    Returns
    -------
    printable table (as string)
    """

    keyranks = sort_df_and_get_keys(metatable[metatable['cases']>mininf], sortkey, num=num, ascending=ascending)
    if columnalias is None:
        cla = [x for x in columns]
    else:
        cla = [x for x in columnalias]
    cla.insert(0,'country')
    cla.insert(0,'')
    LL = []
    srtd2 = metatable2[metatable2['cases']>mininf].sort_values(by=sortkey, ascending=ascending, ignore_index=True)[['key',sortkey]]
    srtd4 = metatable4[metatable4['cases']>mininf].sort_values(by=sortkey, ascending=ascending, ignore_index=True)[['key',sortkey]]
    for i, kk in enumerate(keyranks):
        key10 =  metatable[metatable['key']==kk]['key10'].to_numpy()[0] #abbriev.keys
        # list index 2 and 4 weeks ago, -1 else
        i2l = srtd2[srtd2['key']==kk].index.to_list()
        i4l = srtd4[srtd4['key']==kk].index.to_list()
        if len(i4l)==0:
            i4 = 199
        else:
            i4 = i4l[0]
        if len(i2l) ==0:
            i2 = 199
        else:
            i2 = i2l[0]
    
        def diffsym(i1, i2):
            if i1-i2<0:
                return '\u25b2'
            elif i1==i2:
                return '\u25a0'
            else:
                return '\u25bc'
        r = "%d (%d, %d)  %s %s"%(i+1, i2+1,
               i4+1, diffsym(i, i2), diffsym(i2, i4))
        newl = [r,  key10]
        for ii,key2 in enumerate(columns):
            newl.append(metatable[metatable['key']==kk][key2] * factors[ii])
        LL.append(newl)
    return tabulate(LL, headers = cla, floatfmt=floatfmt, tablefmt=tableformat)